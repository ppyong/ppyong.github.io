---
layout: post
title: EFFECTIVE JAVA 3/E 1장-3장 요약
image: /img/hello_world.jpeg
---

# 2장 객체 생성과 파괴 

## 아이템1 - 생성자 대신 정적 팩터리 메서드를 고려하라

클라이언트가 클래스의 인스턴스를 얻는 전통적인 수단은 public 생성자다. 
하지만 모든 프로그래머가 꼭 알아둬야 할 기법이 하나 더 있는데, 클래스는 생성자와 별도로 정적 팩터리 메서드를 제공할 수 있다. 

### 정적 팩터리 메서드의 장점으로는 

* 이름을 가질 수 있다.   
\-> 하나의 시그니처로는 생성자를 하나만 만들 수 있다. 한 클래스에 시그니처가 같은 생성자가 여러 개 필요할 것 같으면, 생성자를 정적 팩터리 
메서드로 바꾸고 각각의 차이를 잘 드러내는 이름을 지어주자.

* 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.   
\-> 인스턴스를 미리 만들어 놓거나 새로 생성한 인스턴스를 캐싱하여 재활용하는 식으로 불필요한 객체 생성을 피할 수 있다. 
반복되는 요청에 같은 객체를 반환하는 식으로 정적 팩터리 방시의 클래스는 언제 어느 인스턴스를 살아 있게 할지를 철저히 통제할 수 있다. 
이런 클래스를 *일스턴스 통제 클래스*라 한다.

\<참고\>   
플라이웨이트 패턴 : 객체의 내부에서 참조하는 객체를 직접 만드는 것이 아닌 없다면 만들고, 만들어져 있다면 객체는 공유 

* 반환 타입의 하위 타입을 객체로 반화날 수 있는 능력이 있다.    
예) java.util.Collections

* 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.    

* 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 조재하지 않아도 된다.    
이런 유연함은 서비스 제공자 프레임워크를 만드는 근간이 된다. 

그럼 서비스 제공자 프레임워크란 무엇인가?
>다양한 서비스 제공자들이 하나의 서비스를 구성하는 시스템으로, 클라이언트가 실제 구현된 서비스를 이용할 수 있도록 하는데, 클라이언트는 세부적인 구현 내용을 몰라도 서비스를 이용할 수 있다. JDBC는 mysql, oracle 등의 서비스 제공자들이 JDBC라는 하나의 서비스를 구성한다.

서비스 제공자 프레임워크는 3개의 핵심 컴포넌트로 이뤄진다. 
> 구현체의 동작을 정의하는 서비스 인터페이스  (JDBC의 Connection)   
> 제공자가 구현체를 등록할 때 사용하는 제공자 등록 API (DriverManager.registerDriver    
> \-> Class.forName("Driver URI")을 실행 할 경우 지정된 Driver가 로드되며 static절이 실행되고 내부에서 호출)    
> 클라이언트가 서비스의 인스턴스를 얻을 때 사용하는 접근 API (DriverManager.getConnection)

\<참고\>   
브릿지 패턴 : 구현부에서 추상층을 분리하여 각자 독립적으로 변형할 수 있게 하는 패턴 

### 정적 팩터리 메서드의 단점으로는 

* 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩토리 메서드만 제공하면 하위 클래스를 만들 수 없다.      
\-> 상속보다는 컴포지션을 사용하도록 유도하고 불편 타입으로 만들려면 이 제약을 지켜야 한다는 점에서 오히려 장점으로 받아들일 수도 있다.

* 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.    
\-> API 문서를 잘 써놓고 메서드 이름도 널리 알려진 규칙을 따라 짓는 식으로 문제를 완화해줘야 한다. 


## 아이템2 - 생성자에 매개변수가 많다면 빌더를 고려하라 

정적 팩터리와 생성자는 똑같은 제약이 하나 있다. 선택적 매개변수가 많을 때 적절히 대응하기 어렵다는 점이다. 점층적 생성자 패턴도 쓸 수는 있지만, 매개변수 개수가 많아지면 클라이언트 코드를 작성하거나 읽기 어렵다. 

다른 대안으로 자바빈즈 패턴이 있지만 객체 하나를 생성하려면 메서드를 여러 개 호출해야 하고 객체가 완전히 생성되기 전까지는 일관성이 무너진 상태에 놓이게 된다는 단점이 있다. 

점층적 생성자 패턴의 안정성과 자바빈즈 패턴의 가독성을 겸비한 것이 빌더 패턴이다. 

\<추가 학습 필요\>   
19~20 페이지의 피자 관련 소스 
\-> 추가로 학습 후 내용 수정 예정 


## 아이템3 - private 생성자나 열거 타입으로 싱글턴임을 보증하라 

싱글턴이란 인스턴스를 오직 하나만 생성할 수 있는 클래스를 말한다. 싱글턴의 전형적인 예로는 함수와 같은 무상태 객체나 설계상 유일해야 하는 시스템 컴포넌트를 들 수 있다. 그러나 클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트 하기가 어려워질 수 있다. 

싱글턴을 만드는 방식은 보통 둘 중 하나다. 두 방식 모두 생성자는 private으로 감춰두고, 유일한 인스턴스에 접근할 수 있는 수단으로 public static 멤버를 하나 마련해둔다. 


### 1. public tatic 멤버가 final 필드인 방식 

```java
public class Elvis {
  public static final Evlis INSTANCE = new Elvis();
  private Elvis() {...}
  
  public void leaveTheBuilding() {...}
}
```

### 2. 정적 팩터리 메서드를 public static 멤버로 제공

```java
public class Elvis {
  private static final Elvis INSTANCE = new Elvis(); 
  private Elvis() {...}
  public static Elvis getInstance() { return INTANCE; }
  
  public void leaveTheBuilding() {...}
}
```

둘 중 하나의 방식으로 만든 싱글턴 클래스를 직렬화하려면 단순히 Serializable을 구현한다고 선언하는 것만으론느 부족하다. 
모든 인스턴스 필드를 일시적(transient)이라고 선언하고 readResolve 메소드를 제공해야 한다. 

\<참고\>   
transient : 직렬화, 역직렬화 시 해당 변수는 직렬화 하지 않는다. 

## 아이템4 - 인스턴스화를 막으려거든 private 생성자를 사용하라 

## 아이템5 - 자원을 직접 명시하지 말고 의존 격체 주입을 사용하라 

사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식이 적합하지 않지. 
대신 클래스가 여러 자원 인스턴스를 지원해야 하며, 클라이언트가 원하는 자원을 사용해야 한다. 이 조건을 만족하는 간단한 패턴이 있으니, 바로 인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식이다. (전략 패턴인듯?)

## 아이템6 - 불필요한 객체 생성을 피하라 

똑같은 기능의 객체를 매번 생성하기보다는 객체 하나를 재사용하는 편이 나을 때가 많다. 재사용은 빠르고 세련되다. 

```java
String s = new String("TEST"); // 따라 하지 말 것 
```

이 문장은 실행될 때마다 String 인스턴스를 새로 만든다.

개선된 버전은 아래와 같다. 아래와 같이 사용할 경우 새로운 객체를 매번 만드는 대신 하나의 String 인스턴스를 사용한다. (Permanant Area의 Constant Pool 에 등록)

```java
String s = "TEST";
```

불필요한 객체를 만들어내는 또 다른 예로 오토박싱을 들 수 있다. 아래 예제는 끔찍히 느리다. 

```java
private static long sum(){
  Long sum = 0L;
  for(long i = 0; i <= Integer.MAX_VALUE; i++){
    sum += i;
  }
  
  return sum;
}
```

느린 이유는 sum 변수를 long이 아닌 Long으로 선언해서 불필요한 Long 인스턴스가 약 231개나 만들어진 것이다. 박싱된 기본 타입보다는 기본 타입을 사용하고, 의도치 않은 오토박싱이 숨어들지 않도록 주의하자.   

## 아이템7 - 다 쓴 객체 참조를 해제하라 

\<추가 학습 필요\>   
weak reference 

## 아이템8 - finalizer와 cleaner 사용을 피하라 

자바는 두가지 객체 소멸자를 제공한다. 그중 finalizer는 예측할 수 없고, 상황에 따라 위험할 수 있어 일반적으로 불필요하다. cleaner는 finalizer보다는 덜 위험하지만, 여전히 예측할 수 없고, 느리고, 일반적으로 불필요하다.   

그렇다면 파일이나 스레드 등 종료해야 할 자원을 담고 있는 객체의 클래스에서 finalizer나 cleaner를 대신해줄 묘안은 무엇일까? 그저 AutoCloseable을 구현해주고, 클라이언트에서 인스턴스를 다 쓰고 나면 Close 메서드를 호출하면 된다. 

## 아이템9 - try-finally 보다는 try-with-resources를 사용하라 

자바 라이브러리에는 close 메서드를 호출해 직접 닫아줘야 하는 자원이 많다. 자원 닫기는 클라이언트가 놓치기 쉬워서 예측할 수 없는 성능 문제로 이어지기도 한다. 
전통적으로 자원이 제대로 닫힘을 보장하는 수단으로 try-finally 가 쓰였다. 
자바 7부터 등장한 try-with-resource 등장했고 이 구조를 사용하려면 해당 자원이 AutoCloseable 인터페이스를 구현해야 한다. 

```java
static void copy(String src, String dst) throw IOException {
  try (InputStream in = new FileInpuStream(src); 
       OutputStream out = new FileOutputStrea(dst)) {
       byte[] buf = new byte[BUFFER_SIZE];
       int n;
       while((n = in.read(buf)) >= 0)
        out.write(buf, 0, n);
  }
}
```

<hr>

# 3장 모든 객체의 공통 메서드 

## 아이템10 - equals는 일반 규약을 지켜 재정의하라 

equals 메서드는 재정의하기 쉬워 보이지만 곳곳에 함정이 도사리고 있어서 자칫하면 끔직한 결과를 초래한다. 그러니 다음에서 열거한 상황 중 하나에 해당한다면 재정의하지 않는 것이 최선이다. 

* 각 인스턴스가 본질적으로 고유하다.
* 인스턴스의 '논리적 동치성'을 검사할 일이 없다.
* 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다. 
* 클래스가 private이거나 package-private이고 equals 메서드를 호출할 

## 아이템11 - equals를 재정의하려거든 hashCode도 재정의하라   

## 아이템12 - toString을 항상 재정의하라   

## 아이템13 - clone 재정의는 주의해서 진행하라   

Cloneable은 복제해도 되는 클래스임을 명시하는 용도의 믹스인 인터페이스지만, 아쉽게도 의도한 목적을 제대 이루지 못했다. 
clone 메서드 선언된 곳이 Cloneable이 아닌 Object이고 그마저도 protected이기 때문이다. 
그래서 Cloneable을 구현하는 것만으로는 외부 객체에서 clone 메서드를 호출할 수 없다.   

\-> Cloneable은 빈 인터페이스이고 실제 clone 메서드는 protected로 Object에 있기 때문에 상속을 통해 public으로 접근제어자를 변경하지 않는한은 불가능하다. 

그럼 Cloneable은 대 무슨 일을 할까? 이 인터페이스는 *Object의 protected 메서드인 clone의 동작 방식을 결정한다*.



\<추가 학습 필요\>
믹스인 인터페이스

## 아이템14 - Comparable을 구현할지 고려하라    
