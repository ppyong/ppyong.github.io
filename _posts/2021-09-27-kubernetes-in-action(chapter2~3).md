---
layout: post
title: Kubernetes in action 3장 정리
---

> 포드에 여러 컨테이너가 포함돼 있을 때 항상 포드 전부가 단일 워커 노드에서 실행된다. 

- 3.1.1 포드의 필요성

> - 관련 없는 여러 프로세스를 하나의 컨테이너에서 실행하는 경우 모든 프로세스를 실행 상태로 유지하고 로그를 관리하는 것은 사용자의 책임 
> - 충돌이 발생한 경우 개별 프로세스를 자동으로 다시 시작하는 매커니즘을 포함 시켜야함 -> kubernetes 자체 기능이 아닌 직접 구현이 필요하다는 것을 의미한다.
> - 모든 프로세스는 동일한 표준 출력으로 로그를 남기므로 어떤 프로세스가 어떤 내용을 기록했는지 파악하기 어려울 수 있다. 

> -> 포드로 관리할 경우 특정 컨테이너의 로그만을 볼 수 있다. 
```shell
kubectl logs kubia-manual -c ${container명} 
```

- 3.1.2 포드 

> 여러 컨테이너를 단일 단위로 관리할 수 있는 상위 레벨 구조가 필요하다. 컨테이너 포드는 밀접하게 연관된 프로세스를 함께 실행하고 마치 하나의 컨테이너에서 실행되는 것처럼 동일한 환경을 제공하면서 다소 격리된  상태로 유지한다. 포드의 모든 컨테이너는 동일한 네트워크 및 UTS 네임스페이스에서 실행되기 때문에 모두 같은 호스트 이름 및 네트워크 인터페이스를 공유한다. 파일 시스템의 경우 각 컨테이너의 파일 시스템은 다른 컨테이너와 완전히 분리돼 있다. 

> * UTS 네임스페이스 참고자료: https://www.44bits.io/ko/post/container-network-1-uts-namespace

- 컨테이너가 동일한 IP 및 포트 공간을 공유하는 방법 

> - 포드의 컨테이너가 동일한 네트워크에서 실행되므로 네임스페이스의 경우 같은 IP 주소와 포트 공간을 공유한다는 것이다. 따라서 동일한 포트 번호에 바인딩 될 경우 충돌이 발생한다. 
> - 각 포드에는 별도의 공간이 있으므로 다른 포드의 컨테이너는 포트 충동을 일으킬 수 없다. 
> - 포드 내부의 모든 컨테이너에 역시 동일한 루프백 네트워크 인터페이스 가지므로 컨테이너는 localhost로 동일한 포드에서 다른 컨테이너와 통신할 수 있다. 

- 플랫 인터 포드 네트워크 소개 

<img src="/assets/img/kubernetes-in-action-network-image1.png" width="90%">

> 쿠버네티스 클러스터의 모든 포드는 공유된 단일 플랫, 네트워크 주소 공간에 위치하며 이는 모든 포드가 다른 포드의 IP 주소에 있는 다른 모든 포드에 액세스 할 수 있음을 의미한다. 
> 랜상의 컴퓨터와 마찬가지로 각 포드는 자체 IP 주소를 가지며 포드 전용으로 설정된 네트워크를 통해 다른 모든 포드에서 액세스 할 수 있다. 

<img src="/assets/img/k8s-network.png" width="90%">

> 위에 책 자료를 기반으로 조금 자료를 찾아봤다. docker의 경우 각 컨테이너별로 네트워크 네임스페이스를 갖고 있기에 각 컨테이너가 IP를 갖고 있는 형태다. 포드의 경우 같은 포드안에 속한 컨테어는 동일한 IP 즉 네트워크를 공유한다. 이는 pause 컨테이너와 같은 특수한 목적을 가진 컨테이너를 통해서 가능해진다. pause 컨테이너는 veth라는 가상의 네트워크 인터페이스를 생성하고 이 veth는 pod 내부와 host에 pair로 생성된다. 이 veth 를 공유하므로서 모두 같은 네트워크를 공유하게 된다. 또한 이 pair로 생성된 가상 네트워크 인터페이스를 통해 pod 외부와 통신할 수 있게 된다. 

> 책에서 단순 플랫한 네트워크라고 표현되어 있었는데, 이해가 되지 않았던 부분은 docker를 설치 할 경우 기본적으로 docker0이라는 브릿지가 생성되고 이 브릿지를 통해서 컨테이너간 통신이 가능하게 되는데, 이 브릿지는 각 네트워크 대역(cidr)을 갖고 있게 되는데 쿠버네티스 같이 여러 Node를 클러스터로 묶을 경우 "각 Node별 동일한 IP를 가진 포드가 생성될 수 있는거 아닌가?" 라는 의문을 갖게 되었고 그와 동시에 "Node1의 포드A(10.1.1.2)에서 Node2의 포드B(10.1.1.2)로 통신을 시도 할 경우 어떻게 포드를 구분하고 통신이 가능할 수 있지?" 라는 의문 또한 갖게 되었다. 

> 그에 대해 조사하고 위와 같은 그림을 그려보았다. 어떤식으로 이렇게 통신이 가능할까? 

> 이를 위해서 CNI에 대한 이해가 필요하다. 
> * CNI 참고자료 : https://velog.io/@seunghyeon/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B5%AC%EC%84%B1%EB%8F%84

- 3.1.3 컨테이너를 포드 전체에 적절하게 구성하기 

> 포드가 상대적으로 가볍기 때문에 오버헤드를 거의 발생 시키지 않고 많은 포드를 사용할 수 있다. 








