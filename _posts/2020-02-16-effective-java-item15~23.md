---
layout: post
title: EFFECTIVE JAVA 3/E 4장-5장 요약
---

4장 클래스와 인터페이스

## 아이템15 - 클래스와 맴버의 접근 권한을 최소화하라   

"어설프게 설계된 컴포넌트와 잘 설계된 컴포너트의 가장 큰 차이는 바로 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐다"   

오직 API 를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 방식에는 전혀 개의치 않는다. 정보 은닉, 혹은 캡슐화라고 하는 이 개념은 소프트웨어 설계의 근간이 되는 워리다.

정보은닉의 장점으로는 

* 시스템 개발 속도를 높인다.
* 시스템 관리 비용을 낮춘다.
* 정보 은닉 자체가 성능을 높여주진 않지만, 성능 최적화에 도움을 준다.
* 소프트웨어 재사용성을 높인다.
* 큰 시스템을 제작하는 난이도를 낮춘다. 

자바는 정보 은닉을 위한 다양한 장치를 제공한다. 그중 접근 제어 매커니즘은 클래스, 인터페이스 맴버의 접근성을 명시한다. 각 요소의 접근성은 그 요소가 선언된 위치와 접근 제한자로 정해진다.   

기본 원칙은 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다. 달리 말하면, 소프트웨어가 올바로 동작하는 한 항상 가장 낮은 접근 수준을 부여해야 한다는 뜻이다.   

톱레벨 클래스와 인터페이스에 부여할 수 있는 접근 수준은 package-private와 public 두 가지다. public 으로 선언하면 공개 API가 되니 패키지 외부에서 쓸 이유가 없다면 package-private으로 선언하자.  

맴버에 부여할 수 있는 접근 수준은 네 가지다.   

* private: 맴버를 선언한 톱레벨 클래스에만 접근할 수 있다.   
* package-private: 맴버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다.   
* protected: package-private 의 접근 범위를 포함하며, 이 맴버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.   
* public: 모든 곳에서 접근할 수 있다.


클래스의 공개 API를 세심히 설계한 후, 그 외의 모든 맴버는 private으로 만들자. 그런 다음 오직 같은 패키지의 다른 클래스가 접근해야 하는 맴버에 한하여 package-private으로 풀어주자. ***"권한을 풀어주는 일을 자주 하게 된다면 여러분 시스템에서 컴포넌트를 더 분해해야 하는 것 아닌지 다시 고민해보자"***

맴버 접근성을 좁히지 못하게 방해하는 제약이 하나 있다. 상위 클래스의 메서드를 재정의할 때는 그 접근 수준을 상위 클래스에서보다 좁게 설정할 수 없다는 것이다.     
-> **"리스코프 치환 원칙"**

public 클래스의 인스턴스 필드는 되도록 public 이 아니어야 한다. 필드가 가변 객체를 참조하거나, final이 아닌 인스턴스 필드를 public으로 선언하면 그 필드에 담을 수 있는 값을 제한할 힘을 잃게 된다. 또한 public 가변 필드를 갖는 클래스는 일반적으로 스레드 안전하지 않다. (private로 선언하고 public 을 메서드를 통해 공개할 경우 해당 메서드에 동기화 처리를 할 수 있음)    


## 아이템16 - public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라    

패키지 바깥에서 접근할 수 있는 클래스라면 접근 제공자를 제공함으로써 클래스 내부 표현 방식을 언제든 바꿀 수 있는 유연성을 얻을 수 있다. public 클래스가 필드를 공개하면 이를 사용하는 클라이언트가 생겨날 거이므로 내부 표현 방식을 마음대로 바꿀 수 없게된다.    

하지만 package-private 클래스 혹은 private 중첩 클래스라면 데이터 필드를 노출한다 해도 하등의 문제가 없다. 클라이언트 코드가 이 클래스 내부 표현에 묶이기는 하나, 클라이언트도 어차피 이 클래스를 포함하는 패키지 안에서만 동작하는 코드일 뿐이다. 따라서 패키지 바깥 코드는 전혀 손대지 않고도 데이터 표현 방식을 바꿀 수 있다. private 중첩 클래스의 경우라면 수정 범위가 더 좁아져서 이 클래스를 포함하는 외부 클래스까지로 제한된다.    

public 클래스의 필드가 불변이라면 직접 노출할때의 단점이 조금은 줄어들지만, 여전히 결코 좋은 생각이 아니다. API를 변경하지 않고는 표현 방식을 바꿀 수 없고, 필드를 읽을 때 부수 작업을 수행할 수 없다는 단점은 여전하다.    


## 아이템17 - 변경 가능성을 최소화하라 

불변 클래스란 간단히 말해 그 인스턴스의 내부 값을 수정할 수 없는 클래스다. 불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉬우며, 오류가 생길 여지도 적고 훨씬 안전하다.    

클래스를 불변으로 만들려면 

* 객체의 상태를 변경하는 메서드를 제공하지 않는다.    
* 클래스를 확장할 수 없도록 한다.    
* 모든 필드를 final로 선언한다.    
* 모든 필드를 private로 선언한다.    
* 자신 이에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.   

불변 객체는 단순하다. 불변 객체는 생성된 시점의 상태를 파괴될 때까지 그대로 간직한다. 모든 생성자가 불변식을 보장한다면 그 클래스를 사용하는 프로그래머가 다른 노력을 들이지 않더라도 영원히 불변으로 남는다. 

**불변 객체는 근본적으로 스레드 안전하여 따로 동기화할 필요 없다.** 불변 객체는 안심하고 공유할 수 있다. 

객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 이점이 많다. 값이 바뀌지 않는 구성요소들로 이뤄진 객체라면 그 구조가 아무리 복잡하더라도 불변식을 유지하기 훨씬 수월하기 때문이다. 

불변 객체는 그 자체로 실패 원자성을 제공한다. 상태가 절대 변하지 않으니 잠깐이라도 불일치 상태에 빠질 가능성이 없다. 

불변 클래스에도 단점은 있다. 값이 다르면 반드시 독립된 객체로 만들어야 한다는 것이다. 값의 가짓수가 많다면 이들을 모두 만드는데 큰 비용으 치러야 한다. 

이 문제를 대처하는 방법은 두가지다. 

>첫 번째는, 다단계 연산들을 예측하여 기본 기능으로 제공하는 방법이다.    
>두 번째는, 가변 동반 클래스를 사용하는 것이다. 클라이언트들이 원하는 복잡한 연산들을 정확히 예측할 수 있다면 package-private의 가변 동반 클래스만으로 충분하다.    

다음으로 불변 클래스를 만드는 또 다른 방법은 final 클래스로 선언하는 것이지만, 더 유연한 방법은 모든 생성자를 private 혹은 package-private으로 만들고 public 정적 팩터리를 제공하는 방법이다. 정적 팩터리 방식은 다수의 구현 클래스를 활용한 유연성을 제공하고, 이에 더해 다음 릴리스에서 객체 캐싱 기능을 추가해 성능을 끌어 올릴 수도 있다.    

정리해보면

* 클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다. 
* 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자. 
* 생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.


## 아이템18 - 상속보다는 컴포지션을 사용하라   

상속은 코드를 재사용하는 강력한 수단이지만, 항상 최선은 아니다. 잘못 사용하면 오류를 내기 쉬운 소프트웨어를 만들게 된다. 상위 클래스와 하위 클래스를 모두 같은 프로그래머가 통제하는 패키지 안에서라면 상속도 안전한 방법이다. 확장할 목적으로 설계되었고 문서화도 잘 된 클래스도 마찬가지로 안전하다. 

상속의 단점으로는 메서드 호출과 달리 상속은 캡슐화를 깨뜨린다. 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다.   

이런 단점을 피해가는 묘안으로 상속보다는 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하게 하자. 기존 클래스가 새로운 클래스의 구성요소로 쓰인다는 뜻에서 이러한 설계를 **컴포지션**이라 한다.

상속은 반드시 하위 클래스가 상위 클래스의 '진짜' 하위 타입인 상황에서만 쓰여야 한다. 다르게 말하면, 클래스 B가 클래스 A와 is-a 관계일 때문 클래스 A를 상속해야 한다. 다르게 말하면, 클래스 A를 상속하는 클래스 B를 작성하려 한다면 "B가 정말 A인가?"라고 자문해보자. 

컴포지션을 써야 할 상황에서 상속을 사용하는 건 내부 구현을 불필요하게 노출하는 꼴이다. 그 결과 API가 내부 구현에 묶이고 그 클래스의 성능도 영원히 제한된다. 

컴포지션 대신 상속을 사용하기로 결정하기 전에 확장하려는 클래스의 API에 아무런 결함이 없는가? 결함이 있다면, 이 결함이 여러분 클래스의 API까지 전파돼도 괜찮은가? 컴포지션으로는 이런 결함을 숨기는 새로운 API를 설계할 수 있지만, 상속은 상위 클래스의 API를 '그 결함까지도' 그대로 승계한다. 


## 아이템19 - 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라   

## 아이템20 - 추상 클래스보다는 인터페이스를 우선하라      

## 아이템21 - 인터페이스는 구현하는 쪽을 생각해 설계하라      

## 아이템22 - 인터페이스 타입을 정의하는 용도로만 사용하라   

이 지침에 맞지 않는 예로 소위 상수 인터페이스라는 것이 있다. 상수 인터페이스란 메서드 없이, 상수를 뜻하는 static final 필드로만 가득 찬 인터페이스를 말한다. 상수 인터페이스 안티패턴은 인터페이스를 잘못 사용한 예다. 상수 인터페에시를 구현하는 것은 이 내부 구현을 클래스의 API로 노출하는 행위다.    

## 아이템23 - 태그 달린 클래스보다는 클래스 계층 구조를 활용하라   

## 아이템24 - 맴버 클래스는 되도록 static으로 만들라       

중첩 클래스란 다른 클래스 안에 정의된 클래스를 말한다. 주업 클래스는 자신을 감싼 바깥 클래스에서만 쓰여야 하며, 그 외의 쓰임새가 있다면 톱레벨 클래스로 만들어야 한다. 
중첩 클래스의 종류는 정적 멤버 클래스, 비정적 멤버 클래스, 익명 클래스, 지역 클래스 이렇게 네가지다.    

정적 멤버 클래스와 비정적 멤버 클래스의 구문상 차이는 단지 static 이 붙어 있고 없고 뿐이지만, 의미상 차이는 의외로 꽤 크다. 비정적 멤버 클래스의 인스턴스는 바깥 클래스의 인스턴스와 암묵적으로 연결된다.  

멤버 클래스에서 바깥 인스턴스에 접근할 일이 없다면 무조건 static을 붙여서 정적 멤버 클래스로 만들자. static을 생략하면 바깥 인스턴스로의 숨은 외부 참조를 갖게 된다. 이 참조를 저장하려면 시간과 공긴이 소비된다. 더 심각한 문제는 가비지 컬렉션이 바깥 클래스의 인스턴스를 수거하지 못하는 메모리 누수가 생길 수 있다는 점이다. 

## 아이템25 - 톱레벨 클래스는 한 파일에 하나만 담으라    

소스 파일 하나에 톱레벨 클래스를 여러 개 선언하더라도 자바 컴파일러는 불평하지 않는다. 하지만 아무런 득이 없을 뿐더러 심각한 위험을 감수해야 하는 행위다. 

구체적인 예로 다음 소스 파일은 Main킆래스 하나를 담고 있고, Main클래스는 다른 톱레벨 클래스 2개(Utensil과 Dessert)를 참조한다. 
```java
public class Main {
  public static void main(String ...args){
    System.out.println(Utensil.NAME + Dessert.NAME);
  }
}
```

두 클래스가 한 파일 Utensil.java에 정의되어 있다. 
```java
class Utensil {
  static final String NAME = "pan";
}

class Dessert {
  static final String NAME = "cake";
}
```

두 클래스가 한 파일 Dessert.java에 정의되어 있다. 
```java
class Utensil {
  static final String NAME = "pot";
}

class Dessert {
  static final String NAME = "pie";
}
```

위와 같은 경우 운 좋게 javac Main.java Dessrt.java 명령으로 컴파일한다면 컴파일 오류가 나고 Utensil과 Dessert 클래스를 중복 정의했다고 알려줄 것이다. 
한편 javac Main.java 나 javac Main.java Utensil.java 명령으로 컴파일하면 Dessert.java 파일을 작성하기 전처럼 pancake를 출력한다. 그러나 javac Dessert.java Main.java 명령으로 컴파일 하면 potpie를 출력한다. 이처럼 컴퍼일러에 어느 소스 파일을 먼저 건네느냐에 따라 동작이 달라지므로 반드시 바로 잡아야 할 문제다.    


5장 제네릭

## 아이템26 - 로 타입은 사용하지 말라    

클래스와 인터페이스 선언에 타입 매개변수가 쓰이면, 이를 제네릭 클래스 혹은 제네릭 인터페이스라 한다. 제네릭 클래스와 인터페이스를 통틀어 제네릭 타입이라 한다.   
각각의 제네릭 타입은 일련의 매개변수화 타입을 정의한다. 먼저 클래스 이름이 나오고, 이어서 꺽쇠괄호 안에 실제 타입 매개변수를 나열한다. 예전데 List<String>은 원소의 타입이 String인 리스트를 뜻하는 매개변수화 타입이다. 마지막으로, 제네릭 타입을 하나 정의하면 그에 딸린 로 타입도 함께 정의된다. 로 타입이란 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다. 
  
```java
private final Collection stamps = ...;
stamps.add(new Coin(...)); 

for (Iterator i = stamps.iterator(); i.hasNext();) {
  Stamp stamp = (Stamp) i.next(); 
  stamp.cancel();
}
```
이 코드를 사용하면 실수로 도장 대신 동전을 넣어도 아무 오류 없이 컴파일되고 실행된다. 컬렉션에서 이 동전을 다시 꺼내기 전에는 오류를 알아채지 못한다. 
오류는 가능한 한 발생 즉시, 이상적으론느 컴파일할 때 발견하는 것이좋다. 이 예에서는 런타임에 문제를 겪는데 ClassCastException이 발생하면 Stamps에 동전을 넣은 지점을 찾기 위해 코드 전체를 훑어봐야 할 수도 있다. 

```java
private final Collection<Stamp> stamps = ...;
```

이렇게 선언하면 컴파일러는 stamps에는 Stamp의 인스턴스만 넣어야 ㅏㅁ을 컴파일러가 인지하게 되낟. 따라서 아무런 경고 없이 컴파일된다면 의도대로 동작할 것임을 보장한다. 이제 stamps에 엉뚱한 타입의 인스턴스를 넣으려 하면 컴파일 오류가 발생하며 무엇이 잘못됐는지를 정확히 알려준다. 

Test.java:9: incompatible types: Coin cannot be Converted
stamps.add(new Coin));


로 타입을 쓰는 걸 언어 차원에서 막아 놓지는 않았지만 절대로 써서는 안 된다. 로 타입을 쓰면 제네릭이 안겨주는 안전성과 표현력을 모두 잃게 된다. 로 타입은 자바가 기존 코드를 모두 수용하면서 제네릭을 사용하는 새로운 코드와도 맞물려 돌아가게 해야만 했기 때문에 호환성을 위해 로 타입을 지원하고 제네릭 구혀에는 소거 방식을 사용하기로 했다.     

List와 같은 로 타입은 사용해서는 안 되나, List<Object>처럼 임의 객체를 허용하는 매개변수화 타입은 괜찮다. 
List<Object>와 로 타입인 List의 차이는 List는 제네릭 타입에서 완전히 발을 뺀 것이고, List<Object>는 모든 타입을 허용한다는 의사를 컴파일러에 명확히 전달한 것이다. List<Object> 같은 매개변수화 타입을 사용할 때와 달리 List 같은 로 타입을 사용하면 타입 안전성을 잃게 된다.    
  
  
제네릭 타입을 쓰고 싶지만 실제 타입 매개변수가 무엇인지 신경쓰고 싶지 않다면 물음표(?)를 사용하자. 해당 의미는 비한정적 와일드카드 타입인데 이것은 어떤 타입이라도 담을 수 있는 가장 범용적인 매개변수화 타입이다. 

```java
static int numElementsInCommon(Set<?> s1, Set<?> s2) {...}
```

비한정적 와일드카드 타입인 Set<?>과 로 타입인 Set의 차이는 ***로 타입 컬렉션에는 아무 원소나 넣을 수 있으니 타입 불변식을 훼손하기 쉽다. 반면 Collection<?>에는 null외에는 어떤 원소도 넣을 수 없다.*** 다른 원소를 넣으려 하면 컴파일할 때 오류를 보게 될 것이다.    

이러한 제약을 받아들일 수 없다면 제네릭 메서드나 한정적와일드카드 타입을 사용하면 된다.    

로 타입을 쓰지 말라는 규칙에도 소소한 예외가 몇개 있는데, 

* class 리터럴에는 로 타입을 써야한다. 
* 런타임에는 제네릭 타입 정보가 지워지므로 instanseof 연산자는 비한정적 와일드카드 타입 이외의 매개변수화 타입에는 적용할 수 없다   


## 아이템27- 비검사 경고를 제거하라  

할 수 있는 한 모든 비검사 경고를 제거하라. 모두 제거한다면 그 코드는 타입 안전성이 보장된다. 즉, 런타이에 ClassCastException이 발생할 일 없고, 여러분이 의도한 대로 잘 동작하리라 확실할 수 있다.  
경고를 제거할 수는 없지만 타입 안전하다고 확신할 수 있다면 @SuppressWarnings("unchecked") 애너테이션을 달아 경고를 숨기자. 안전하다고 검증된 비검사 경고를 그대로 두면, 진짜 문제를 알리는 새로운 경고가 나와도 눈치채지 못할 수 있다. 제거하지 않은 수만은 거짓 경고 속에 샐운 경고가 파묻힐 수 있다. 

@SuppressWarnings("unchecked") 애너테이션은 개별 지역변수 선어부터 클래스 전체까지 어떤 선언에도 발 수 있지만 가능한 한 좁은 범위에 적용하자. 보통은 변수 선언, 아주 짧은 메서드, 혹은 생성자가 될 것이다. 자칫 심각한 경고를 놓칠 수 있으니 절대로 클래스 전체에 적용해서는 안 된다. 

@SuppressWarnings("unchecked") 애너테이션을 사용할 때는 그 경고를 무시해도 안전한 이유를 항상 주석으로 남겨야 한다.     

## 아이템28 - 배열보다는 리스트를 사용하라 

배열과 제네릭 타입에서 중요한 차이는 

1. 배열은 공변이다. Sub가 Super의 하위 타입이라면 배열 Sub[]는 배열 Super[]의 하위 타입이 된다(공변, 즉 함께 변한다). 반면 제네릭은 불공변이다. 즉, 서로 다른 타입 Type1과 Type2가 있을 때, List<Type1>은 List<Type2>의 하위 타입도 아니고 상위 타입도 아니다.

2. 배열은 실체화 된다. 배열은 런타임엗 자신이 담기로 한 원소의 타입을 인지하고 확인한다. 반면 제네릭은 타입 정보가 런타임에는 소거된다. 원소 타입을 컴파일 타임에만 검사하며 런타임에는 알수조차 없다는 뜻이다.   

이상의 주요 차이로 인해 배열과 제네릭은 잘 어우러지지 못한다. 예컨대 배열은 제네릭 타입, 매개변수화 타입, 마입 매개변수로 사용할 수 없다. 

E, List<E>, List<String> 같은 타입을 실체화 불가 타입이라 한다. 실체화되지 않아서 런타임에는 컴파일타임보다 타입 정보를 적게 가지는 타입이다. 소거 메커니즘 때문에 매개변수화 타입 가운데 실체화될 수 있는 타입은 List<?>,와 Map<?,?> 같은 비한정적 와일드카드 타입뿐이다.     
  
## 아이템29 - 이왕이면 제네릭 타입으로 만들라    

\<추가 학습\>
힙 오염    

## 아이템30 - 이왕이면 제네릭 메서드로 만들라   

## 아이템31 - 한정적 와일드카드를 사용해 API 유연성을 높이라 

## 아이템32 - 제네릭과 가변인수를 함께 쓸 때는 


  
